// Example 10: Advanced Multi-Mode Reasoning
// This example combines multiple VSAR features to demonstrate
// the system's capability as a flexible reasoning substrate.

@model FHRR(dim=8192, seed=42);
@beam(width=50);
@novelty(threshold=0.95);

// ============================================================================
// SCENARIO: Enterprise Security & Access Control System
// ============================================================================

// Employees and their departments
fact employee(alice, engineering).
fact employee(bob, engineering).
fact employee(charlie, sales).
fact employee(david, security).
fact employee(eve, hr).

// Management relationships
fact manages(alice, bob).      // Alice manages Bob
fact manages(charlie, david).  // Charlie manages David

// Security clearance levels
fact clearance(alice, top_secret).
fact clearance(bob, secret).
fact clearance(charlie, confidential).
fact clearance(david, top_secret).
fact clearance(eve, public).

// Access permissions
fact has_access(alice, server_room).
fact has_access(david, server_room).
fact has_access(bob, lab).

// Security incidents
fact incident(server_room, thursday).
fact incident(lab, friday).

// Trusted relationships (positive)
fact trusted(alice, bob).
fact trusted(charlie, david).

// Adversarial relationships (classical negation)
fact ~trusted(eve, charlie).   // Eve does not trust Charlie

// ============================================================================
// RULES: Multi-hop inference and security policies
// ============================================================================

// Transitive management: X supervises Z if X manages Y who manages Z
rule supervises(X, Z) :- manages(X, Y), manages(Y, Z).

// Clearance hierarchy: Higher clearance implies lower access
// (This is a simplification; real systems are more complex)
rule has_clearance(X, secret) :- clearance(X, top_secret).
rule has_clearance(X, confidential) :- clearance(X, secret).

// Access inference: Managers inherit subordinate access
rule can_access(X, Resource) :- manages(X, Y), has_access(Y, Resource).

// Suspect identification: Someone with access but untrusted
// Uses negation-as-failure (NAF)
rule suspect(X, Location) :-
    has_access(X, Location),
    incident(Location, Day),
    not trusted(X, Person).

// Investigation leads: People who could access incident location
rule investigation_lead(X, Location) :-
    can_access(X, Location),
    incident(Location, Day).

// ============================================================================
// QUERIES: Demonstrating different reasoning modes
// ============================================================================

// --- Single-Variable Queries (Phase 1) ---
query employee(X, engineering)?         // All engineering employees
query manages(alice, X)?                // Who does Alice manage?
query clearance(X, top_secret)?         // Who has top secret clearance?

// --- Multi-Variable Queries (Phase 4) ---
// Note: Multi-variable queries require API access
// query manages(?, ?)?                    // All management relationships - use API
// query incident(?, ?)?                   // All incidents (location + day) - use API
// Example: Query(predicate="manages", args=[None, None])
query has_access(X, server_room)?       // Everyone with server room access

// --- Rule-Based Inference (Phase 2) ---
query supervises(alice, X)?             // Who does Alice supervise transitively?
query can_access(alice, X)?             // What can Alice access (direct + inherited)?
query has_clearance(bob, X)?            // What clearance levels does Bob satisfy?

// --- Negation-as-Failure Queries (Phase 3) ---
query suspect(X, server_room)?          // Who are suspects for server room incident?
                                        // Returns: People with access but no trust relationships

// --- Investigation Queries ---
query investigation_lead(X, lab)?       // Who had potential access to lab during incident?

// ============================================================================
// EXPECTED INSIGHTS
// ============================================================================

// Multi-hop:
//   - Alice can access lab (via managing Bob who has access)
//   - supervises relationships derived from manages chains

// Negation:
//   - suspect(eve, server_room) if Eve had access (not in this dataset)
//   - Only people WITHOUT any trusted relationships are suspects

// Multi-variable:
//   - All (manager, subordinate) pairs in one query
//   - All (location, day) incident pairs
//   - Demonstrates 100% accuracy via successive interference cancellation

// Approximate matching:
//   - High similarity scores (>0.9) for direct facts
//   - Slightly lower (~0.85-0.9) for derived facts
//   - Graceful degradation with inference depth

// ============================================================================
// EXTENSIBILITY NOTES
// ============================================================================

// This example demonstrates VSAR as a FLEXIBLE REASONING SUBSTRATE.
// The same encoding supports:
//
// 1. Deductive reasoning (forward chaining, Horn rules)
// 2. Multi-variable retrieval (successive interference cancellation)
// 3. Negation-as-failure (safety checks, absence reasoning)
// 4. Approximate matching (similarity scores, noise tolerance)
//
// Future modes (not yet in VSARL syntax):
// - Abduction: Generate hypotheses for observed facts
// - Analogical: Transfer structure from similar scenarios
// - Probabilistic: Weighted belief propagation
// - Case-based: Retrieve and adapt similar cases
//
// All modes share the SAME ENCODING LAYER (hybrid predicate binding + shift).
// Only the DECODING STRATEGY changes between modes.
